/**
 * file exp_DakotaInterface.h
 * 
 * Header for class DakotaInterface and subclasses.
 */

// Copyright 2010 Sandia National Laboratories

#ifndef EXP_DAKOTAINTERFACE
#define EXP_DAKOTAINTERFACE

#include "zuzax/base/ct_defs.h" 
#include "zuzax/base/ctexceptions.h"

#include <fstream>
#include <iostream>


/** 
 * This class deals with parsing a parameter input file 
 * that is automactically generated by Dakota and 
 * giving access to these parameters. 
 */
class DakotaInterface {
  
 public:
  
  //!  Constructor
  DakotaInterface(  ) : 
    paramFile_( "params.in" ), resultsFile_( "results.out" ) {
    parseInput();
  }
    
  //!  Constructor.
    DakotaInterface( std::string paramFileName, std::string resultsFileName ): 
    paramFile_( paramFileName ), resultsFile_( resultsFileName ) { 
    parseInput();
  }      
      
  //! Destructor.
  ~DakotaInterface(  ) { ; }
  
  //!  Copy Constructor.
  DakotaInterface( const DakotaInterface &right ) 
  { *this = right; }
  
  //! Assignment operator
  DakotaInterface&  operator=(const DakotaInterface& right) {
    if (&right != this) { return *this; }
    paramFile_      = right.paramFile_;
    resultsFile_    = right.resultsFile_;
    nvar_           = right.nvar_;
    paramMap_       = right.paramMap_;
    return *this;
  }

  //! Parse the parameter input files
  void parseInput()  {

    std::ifstream ifp( paramFile_.c_str() );
    if ( ifp.is_open() )  //check that the file exists
      {
	std::string dummyString;
	//get the number of variables in the file    
	ifp >> nvar_ >> dummyString;	

	double value;
	std::string name;
	for (int i = 0; i < nvar_; i++ ) {
	  ifp >> value  >> name;
	  paramMap_[ name ] = value;
	}
	ifp.close();
      }
  }

  //! Write result to output files.  This method only handles a single value.
  void writeResult( double value )  {
    std::ofstream ofp( resultsFile_.c_str() );
    ofp << value << std::endl;	
    ofp.close();
  }


  //! Return the parameter value given its name, zero for absent parameters. 
  double value( std::string varName ){
    if ( paramMap_.find( varName ) != paramMap_.end() )
      return paramMap_[varName];
    else
      return 0.0;
  }

  //! Return the number of parameters that are in the parameter map
  int hasParams( ){
    return paramMap_.size();
  }

  //! Return true (non-zero) if parameter varName is in parameter map.
  int hasParam( std::string varName ){
    if ( !hasParams() ) return 0;
    return ( paramMap_.find( varName ) != paramMap_.end() );
  }

  //! Set file name for parameters input
  void setParamFileName( std::string name ) { paramFile_ = name; }

  //! Set file name for results output
  void setResultsFileName( std::string name ) { resultsFile_ = name; }

  //! Echo the parameters and their values
  void writeParameters()  {
    //iterate through the map
    std::map<std::string,double>::iterator iter;
    for ( iter = paramMap_.begin(); iter != paramMap_.end(); iter++ ) {
      std::cout << "parameter " << iter->first 
		<< " has value " << iter->second << std::endl;
    }
  }


 protected:
  //! file name for parameters input
  std::string paramFile_;

  //! file name for results output
  std::string resultsFile_;

  //! number of input parameter variables 
  int nvar_;

  //! Map between variable names and values given in 'params.in' file
  std::map<std::string,double> paramMap_;

 private:

};


#endif // EXP_BOUNDARYCONDITION
